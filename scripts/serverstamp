#!/bin/bash

#+++___________________________________________________________________________________
#
#
# Script name:                  serverstamp
#
# Description:
#
# Parameters:
#
# Environment:
#
# Return codes:
#
# Modification history:
#
#       28-Jul-2025     1.0     oracle    Original version
#
#+++___________________________________________________________________________________

CS_TOP=${CS_TOP:-/opt/dsp}
. ${CS_TOP}/env/dsp.env
. ${CS_TOP}/env/funcs.sh

USAGE_STRING="[-f [-x]]"

DEBUG=NO

FORCE=NO
FULL_FORCE=NO		# if FULL_FORCE then offer option to keep existing serverid
			# even if serverstampcheck highlights a failiure
ALLOW_KEEP_ID=YES

while getopts 'fx' OPTION
do
    case "$OPTION" in
        f) FORCE=YES ;;
        x) FULL_FORCE=YES ;;
        ?) usage ;;
    esac
done

if [ "${FULL_FORCE}" = "YES" ] && [ "${FORCE}" != "YES" ]
then
    echo "ERROR: -x option only allowable when -f option used - exiting"
    usage
fi

user=$(whoami)

if [ "${user}" = "" ]
then
    echo "ERROR: could not determine user - exiting"
    EXITCODE=1
    exit ${EXITCODE}
fi

if [ -f ${DSP_IDENTITY_FILE} ] 
then
    if [ "${FORCE}" != "YES" ]
    then
        echo "ERROR: identity file [${DSP_IDENTITY_FILE}] already exists and force option [-f] not specified - exiting"
        EXITCODE=1
        exit $EXITCODE
    fi

    serverstampcheck 2>&1 > /dev/null
    status=$?

    if [ $status -ne 0 ] && [ "${FULL_FORCE}" != "YES" ]
    then
       # if DSP_IDENTITY_FILE exists and serverstampcheck is reporting a discrepency then
       # force user to choose new serverid by setting ALLOW_KEEP_ID to NO thus not presenting
       # user with "Keep Existing" menu option.  However, if FULL_FORCE -x option is specified
       # on command line then allow it
       ALLOW_KEEP_ID="NO" 
    fi
else
    # identity file does not exist so does not make sense to allow the "Keep existing"
    # UUID
    ALLOW_KEEP_ID=NO
fi

#
# outstanding mods:
#   - make sure running as correct owner

#
# Define local script variables
#

#
# Script starts here
#
#
set_error_trap


owner=$(cut -d: -f1 ${DSP_OWNER_FILE})
dspserverid=$(grep ^dspserverid: ${DSP_IDENTITY_FILE} | cut -d: -f2)

if [ "${user}" != "root" ] && [ "${user}" != "${owner}" ]
then
    echo "ERROR: this user [${user}] does not match owner [${owner}] - exiting"
    EXITCODE=1
    exit $EXITCODE
fi

serversummary

newid=$(uuidgen)
status=$?



echo
echo
echo "Hostname"
echo "--------"
echo "${HOSTNAME}"
echo
echo
echo "Register UUID for the server ID"
echo "-------------------------------"
echo
if [ "${newid}" != "" ] && [ $status -eq 0 ]	# uuidgen exists and we could generate our own uuid
then
  unset selections

  if [ "${ALLOW_KEEP_ID}" = "YES" ]
  then
      selections=("Keep existing" "Generate a server ID" "Provide a UUID to use for server ID")
  else
      selections=("Generate a server ID" "Provide a UUID to use for server ID")
  fi
  choose_from_menu "Please select a MAC address to use to stamp this server" selected_choice "${selections[@]}"
  echo "Selected choice: $selected_choice"

  if [ "${selected_choice}" = "Provide a UUID to use for server ID" ]
  then
      echo -n "Enter the UUID you wish to stamp for this server: "
      read newid
  elif [ "${selected_choice}" = "Keep existing" ]
  then
      if [ "${dspserverid}" = "" ]
      then
          echo "ERROR: Keep existing requires dspserverid to be set in ${DSP_IDENTITY_FILE} but it is not found - exiting"
          EXITCODE=1
          exit $EXITCODE
      fi
      newid=$(echo ${dspserverid})	# echo to help get rid of whitespace
  fi
else
    echo "WARNING: uuidgen not available - you will need to specify a UUID"
    echo

    echo -n "Enter the UUID you wish to stamp for this server: "
    read newid
fi

echo ""
echo ""
echo "Choose MAC Address"
echo "------------------"
echo

unset selections
selections=( $(showmacaddrs | grep -v '00:00:00:00:00:00') )
#readarray -t selections < ${tmpfile}.array
choose_from_menu "Please select a MAC address to use to stamp this server" selected_choice "${selections[@]}"
macaddr=${selected_choice}

echo ""
echo ""
echo "Choose IP Address"
echo "-----------------"

unset selections
selections=( $(showipaddrs | sort -n) )
choose_from_menu "Please select an IP address to use to stamp this server" selected_choice "${selections[@]}"
ipaddr=${selected_choice}

echo ""
echo ""
echo "Choose machine type"
echo "-------------------"

unset selections
selections=( "physical server" "virtual machine (on-prem)" "virtual machine (cloud)")
choose_from_menu "Please select a machine type" selected_choice "${selections[@]}"
machine_type=${selected_choice}

echo machine_type=${machine_type}

case "${machine_type}" in
    "physical server" ) prefix="0[0-9][0-9]" ;;
    "virtual machine (on-prem)" ) prefix="1[0-9][0-9]" ;;
    "virtual machine (cloud)" ) prefix="2[0-9][0-9]" ;;
    *) ;;
esac

grep ^${prefix}: ${SERVERCODE_LOOKUP_FILE} | awk -F: '{print $2}'  > ${tmpfile}.array

IFS_SAVE=${IFS}
IFS=$'\n'
selections=( $(cat ${tmpfile}.array) )
IFS=${IFS_SAVE}

choose_from_menu "Please select a machine sub-type" selected_choice "${selections[@]}"
machine_subtype=${selected_choice}

# not the use of awk variable machine_subtype so $2 == machine_subtype is comparing the awk variable
machine_subtype_code=$(awk -v machine_subtype="${machine_subtype}" -F: '$2 == machine_subtype {print $1}' ${SERVERCODE_LOOKUP_FILE})

#
# double-check validation
X=$(grep ^${machine_subtype_code}: ${SERVERCODE_LOOKUP_FILE} | awk -F: '{print $2}')

if [ "${X}" != "${machine_subtype}" ] # something weird has happened
then
    echo "ERROR: unknown error - double-check validation failed on machine_subtype - please raise with code maintainer(s) - exiting"
    EXITCODE=1
    exit
fi

echo ""
echo ""
echo "Choose Database Hosting Status"
echo "------------------------------"

unset selections
grep ^[0-9].*: ${DBHOSTING_LOOKUP_FILE} | awk -F: '{print $2}' > ${tmpfile}.array

IFS_SAVE=${IFS}
IFS=$'\n'
selections=( $(cat ${tmpfile}.array) )
IFS=${IFS_SAVE}

choose_from_menu "Please select a machine sub-type" selected_choice "${selections[@]}"
dbhosting_status=${selected_choice}

# not the use of awk variable dbhosting_status so $2 == dbhosting_status is comparing the awk variable
dbhosting_status_code=$(awk -v dbhosting_status="${dbhosting_status}" -F: '$2 == dbhosting_status {print $1}' ${DBHOSTING_LOOKUP_FILE})

#
# double-check validation
X=$(grep ^${dbhosting_status_code}: ${DBHOSTING_LOOKUP_FILE} | awk -F: '{print $2}')

echo X=[$X]
echo dbhosting_status=[$dbhosting_status]
if [ "${X}" != "${dbhosting_status}" ] # something weird has happened
then
    echo "ERROR: unknown error - double-check validation failed on dbhosting_status - please raise with code maintainer(s) - exiting"
    EXITCODE=1
    exit
fi



echo ""
echo "CONFIRMATION"
echo "------------"
echo
echo "The following will be used to stamp this server:"
echo ""
echo "    hostname  : ${HOSTNAME}"
echo "    server id : ${newid}"
echo ""
echo "   machine-id : ${machine_id}"
echo "       hostid : ${hostid}"
echo ""
echo "     mac addr : ${macaddr}"
echo "      ip addr : ${ipaddr}"
echo ""
echo "  server type : ${machine_subtype}"
echo "   db hosting : ${dbhosting_status}"
echo ""
echo "Press [ENTER] to proceed or <ctrl-C> to cancel"
read userinput
echo

now_epoch=$(date +%s)	# time since epoch, we capture this as we store date/time below a couple
		        # of times with/without TZ for example and want to make sure they are
        		# identical

now_local=$(date -d@${now_epoch} +%Y%m%d_%H%M%S)
now_utc=$(date -u -d@${now_epoch} +%Y%m%d_%H%M%S)
now_tz=$(date -d@${now_epoch} +%Z)
now_tz_offset=$(date -d@${now_epoch} +%:z)

if [ -f ${DSP_IDENTITY_FILE} ]
then
    cp ${DSP_IDENTITY_FILE} ${DSP_IDENTITY_FILE}.${now_local}
    status=$?
fi

(
    echo "hostname: ${HOSTNAME}"
    echo "dspserverid: ${newid}"
    echo "macaddr:  ${macaddr}"
    echo "ipaddr:   ${ipaddr}"
    echo "servercode: ${machine_subtype_code}"
    echo "dbhostingstatus: ${dbhosting_status_code}"
    echo "machine-id: ${machine_id}"
    echo "hostid:     ${hostid}"
    echo "time_local: ${now_local}"
    echo "time_tz:    ${now_tz}"
    echo "time_tz_offset:${now_tz_offset}"
    echo "time_utc:   ${now_utc}"
    echo
    echo "<ip_addrs:${now_local}>"
    showipaddrs
    echo "</ip_addrs:${now_local}>"
    echo "<mac_addrs:${now_local}>"
    showmacaddrs
    echo "</mac_addrs:${now_local}>"
) > ${DSP_IDENTITY_FILE}
status=$?

serversummary




echo

exit $EXITCODE

