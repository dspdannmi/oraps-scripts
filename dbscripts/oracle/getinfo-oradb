#!/bin/bash
set +x

#+++___________________________________________________________________________________
#
#
# Script name:                  getinfo-oradb
#
# Description:
#
# Parameters:
#
# Environment:
#
# Return codes:
#
# Modification history:
#
#       22-Oct-2025     1.0     oracle    Original version
#
#+++___________________________________________________________________________________

CS_TOP=/opt/dsp
. ${CS_TOP}/env/dsp.env
. ${CS_TOP}/env/funcs.sh

USAGE_STRING="[-d ORACLE_SID] [-m lite|basic|comp] [-s human|machine]"

mode="lite"
style="human"

while getopts 'd:m:s:' OPTION
do
    case "$OPTION" in
        d) ORACLE_SID=$OPTARG ;;
        m) mode=$OPTARG ;;
        s) style=$OPTARG ;;
        ?) usage ;;
    esac
done

case "${mode}" in
    [lL][iI][tT][eE] ) mode=lite ;;
    [bB][aA][sS][iI][cC] ) mode=basic ;;
    [cC][oO][mM][pP] ) mode=comp ;;
    *) echo "ERROR: invalid mode [${mode}] - exiting" ; exit 1 ;;
esac

case "${style}" in
    [hH][uU][mM][aA][nN]) style=human;;
    [mM][aA][cC][hH][iI][nN][eE]) style=machine;;
    *) echo "ERROR: invalid style [${style}] - exiting" ; exit 1 ;;
esac

#if [ "${ORACLE_SID}" != "" ]
#then
#    . ${ORAENV} 2>&1 > /dev/null
#    status=$?
#
#    if [ $status -ne 0 ]
#    then
#        echo "ERROR: encountered error when running oraenv - exiting"
#        EXITCODE=1
#	exit ${EXITCODE}
#    fi
#else
#    echo "ERROR: ORACLE_SID not set and not passed via command line - exiting"
#    exit 1
#else
#    . ${ORAENV} 2>&1 > /dev/null
#    status=$?
#fi


if [ ! -d ${ORACLE_HOME} ]
then
   echo "ERROR: ${ORACLE_HOME} does not exist - exiting"
   exit 1
fi

typeset -i lvl
typeset -i level


export PATH=${ORACLE_HOME}/OPatch:${ORACLE_HOME}/bin:${PATH}

function print_begin
    {
    padding=""
    lvl=1
    while [ ${lvl} -lt ${level} ]
    do
        padding="    ${padding}"
        let lvl=${lvl}+1
    done

    if [ "${style}" = "human" ]
    then
        echo "${padding}---------------------------------------------------"
        echo "${padding}${1}"
        echo "${padding}---------------------------------------------------"
    else
        echo "${padding}<BEGIN_${1}>"
    fi
    }


function print_end
    {
    padding=""
    lvl=1
    while [ ${lvl} -lt ${level} ]
    do
        padding="    ${padding}"
        let lvl=${lvl}+1
    done

    if [ "${style}" = "human" ]
    then
        echo ""
    else
        echo "${padding}<END_${1}>"
    fi
    }


function show_opatch_version
    {
    level=$1
    TAG=OPATCH_VERSION

    print_begin ${TAG}

    padding="    ${padding}"
    ${ORACLE_HOME}/OPatch/opatch version | sed -e s"/^/${padding}/"
    status=$?

    print_end ${TAG}
    }



#
# Define local script variables
#


#
# Script starts here
#
#
set_error_trap

level=1
TAG=ORACLE_SID

if [ "${ORACLE_SID}" = "" ]
then
    echo "ERROR: ORACLE_SID not set and not passed on command line - exiting"
    EXITCODE=1
    exit ${EXITCODE}
fi

print_begin ${TAG}

padding="    ${padding}"
echo "${padding}ORACLE_SID:        ${ORACLE_SID}"
echo ""

if chkoradbinoratab ${ORACLE_SID} 2>&1 > /dev/null
then
    :
else
    echo "${padding}STATUS:            instance not configured in ${ORATAB}"
    echo ""
    EXITCODE=1
    exit ${EXITCODE}
fi

export ORACLE_SID
export ORAENV_ASK=NO
. ${ORAENV} 2>&1 > /dev/null

if [ "${ORACLE_HOME}" = "" ]
then
    echo "${padding}ORACLE_HOME:	not set - exiting"
    EXITCODE=1
    exit ${EXITCODE}
fi

if chkorainstsysdba ${ORACLE_SID} 2>&1 > /dev/null
then
    :
else
    echo "${padding}STATUS:            instance not started"
    echo ""
    EXITCODE=1
    exit ${EXITCODE}
fi

##
## Determine version
##   REMOVING AS DOESNT WORK WHEN DATABASE
##   IN NOMOUNT OR MOUNTED ONLY WHEN OPEN
##
#version=$(getdbversion -d ${ORACLE_SID})
#
#echo "${padding}VERSION:           ${version}"
#echo ""

#
# ORACLE_HOME
#
echo "${padding}ORACLE_HOME:       ${ORACLE_HOME}"

#
# Determine alert log
#
ALERTLOG=$(showalertlogloc)

echo "${padding}ALERT LOG:         ${ALERTLOG}"

#
# Password file
#
ORAPW_FILE=${ORACLE_HOME}/dbs/orapw${ORACLE_SID}

if [ -r ${ORAPW_FILE} ]
then
    ORAPW_FILE_EXISTS=true
else
    ORAPW_FILE_EXISTS=false
    ORAPW_FILE="${ORAPW_FILE} [***DOES NOT EXIST***]"
fi

echo "${padding}PASSWORD FILE:     ${ORAPW_FILE}"

# expecting some errors on older versions as newer columns etc.
# are added to DBA_ and V$_ as versions increment so run with
# -c flag to prevent exit on error
runsql -c -d ${ORACLE_SID} getinfo.sql > ${tmpfile}


awk '/<V_INSTANCE>/ {
                                     process="true"
                                     next
                                     }
                                     /<\/V_INSTANCE>/ {
                                     process=""
                                     next
                                     }
                                     process=="true" {
                                     print
                                     }' ${tmpfile} > ${tmpfile}.v_instance

awk '/<V_DATABASE>/ {
                                     process="true"
                                     next
                                     }
                                     /<\/V_DATABASE>/ {
                                     process=""
                                     next
                                     }
                                     process=="true" {
                                     print
                                     }' ${tmpfile} > ${tmpfile}.v_database

awk '/<V_PDBS>/ {
                                     process="true"
                                     next
                                     }
                                     /<\/V_PDBS>/ {
                                     process=""
                                     next
                                     }
                                     process=="true" {
                                     print
                                     }' ${tmpfile} > ${tmpfile}.pdbs


awk '/<V_PARAMETERS>/ {
                                     process="true"
                                     next
                                     }
                                     /<\/V_PARAMETERS>/ {
                                     process=""
                                     next
                                     }
                                     process=="true" {
                                     print
                                     }' ${tmpfile} > ${tmpfile}.v_parameters


INSTANCE_NAME=$(grep '^INSTANCE_NAME[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
VERSION=$(grep '^VERSION[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
VERSION_LEGACY=$(grep '^VERSION_LEGACY[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
VERSION_FULL=$(grep '^VERSION_FULL[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
STARTUP_TIME=$(grep '^STARTUP_TIME[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
DATABASE_STATUS=$(grep '^DATABASE_STATUS[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
INSTANCE_ROLE=$(grep '^INSTANCE_ROLE[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
ACTIVE_STATE=$(grep '^ACTIVE_STATE[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
INSTANCE_MODE=$(grep '^INSTANCE_MODE[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
EDITION=$(grep '^EDITION[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
FAMILY=$(grep '^FAMILY[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)
DATABASE_TYPE=$(grep '^DATABASE_TYPE[ ]*:' ${tmpfile}.v_instance | cut -d: -f2- | xargs)


DBID=$(grep '^DBID[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
NAME=$(grep '^NAME[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
CREATED=$(grep '^CREATED[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
LOG_MODE=$(grep '^LOG_MODE[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
OPEN_MODE=$(grep '^OPEN_MODE[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
PROTECTION_MODE=$(grep '^PROTECTION_MODE[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
PROTECTION_LEVEL=$(grep '^PROTECTION_LEVEL[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
DATABASE_ROLE=$(grep '^DATABASE_ROLE[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
SUPPLEMENTAL_LOG_DATA_MIN=$(grep '^SUPPLEMENTAL_LOG_DATA_MIN[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
FORCE_LOGGING=$(grep '^FORCE_LOGGING[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
CURRENT_SCN=$(grep '^CURRENT_SCN[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
FLASHBACK_ON=$(grep '^FLASHBACK_ON[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
DB_UNIQUE_NAME=$(grep '^DB_UNIQUE_NAME[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)
CDB=$(grep '^CDB[ ]*:' ${tmpfile}.v_database | cut -d: -f2- | xargs)

NUMBER_OF_STANDBY_DEST=$(grep '^NUMBER_OF_STANDBY_DEST:' ${tmpfile} | cut -d: -f2- | xargs)
DBSIZE_GB=$(grep '^DBSIZE_GB:' ${tmpfile} | cut -d: -f2- | xargs)

CLUSTER_DATABASE=$(grep '^cluster_database[ ]*:' ${tmpfile}.v_parameters | cut -d: -f2- | xargs)

padding="    ${padding}"

echo ""
echo "${padding}db name                  : ${NAME}"
echo "${padding}db unique name           : ${DB_UNIQUE_NAME}"
echo "${padding}instance name            : ${INSTANCE_NAME}"
echo "${padding}created                  : ${CREATED}"
echo "${padding}startup time             : ${STARTUP_TIME}"
echo "${padding}dbid                     : ${DBID}"
echo ""
echo "${padding}cluster_database         : ${CLUSTER_DATABASE}"
echo ""
echo "${padding}dbsize(total)            : ${DBSIZE_GB}Gb"
echo ""

if [ "${CDB}" = "" ]
then
    CDB="NO"
fi

echo "${padding}cdb                      : ${CDB}"

echo "${padding}edition                  : ${EDITION}"
echo "${padding}database status          : ${DATABASE_STATUS}"

if [ "${VERSION_FULL}" != "" ]	# version_full only in versions from about 11g onwards
then
    VERSION=${VERSION_FULL}
fi
echo "${padding}version                  : ${VERSION}"

echo "${padding}open mode                : ${OPEN_MODE}"
echo ""

echo "${padding}TDE                      : <unknown - check not yet implemented>"
echo ""

echo "${padding}last successful bkup     : <unknown - check not yet implemented>"
echo "${padding}current scn              : ${CURRENT_SCN}"
echo "${padding}log mode                 : ${LOG_MODE}"
echo "${padding}flashback on             : ${FLASHBACK_ON}"
echo "${padding}force logging            : ${FORCE_LOGGING}"
echo "${padding}supplemental log data min: ${SUPPLEMENTAL_LOG_DATA_MIN}"

echo ""


if [ "${NUMBER_OF_STANDBY_DEST}" != "" ] && [ "${NUMBER_OF_STANDBY_DEST}" != "0" ]
then
    echo "${padding}standby archlog dests    : ${NUMBER_OF_STANDBY_DEST}"
    echo "${padding}number of standby dest   : ${NUMBER_OF_STANDBY_DEST}"
    echo "${padding}instance role            : ${INSTANCE_ROLE}"
    echo "${padding}database role            : ${DATABASE_ROLE}"
    echo "${padding}protection mode          : ${PROTECTION_MODE}"
    echo "${padding}protection level         : ${PROTECTION_LEVEL}"
else
    if [ "${NUMBER_OF_STANDBY_DEST}" = "" ]
    then
        NUMBER_OF_STANDBY_DEST=0
    fi

    echo "${padding}standby archlog dests    : ${NUMBER_OF_STANDBY_DEST}"
fi

echo ""

echo "${padding}active status            : ${ACTIVE_STATE}"
echo "${padding}instance mode            : ${INSTANCE_MODE}"
echo "${padding}family                   : ${FAMILY}"
echo "${padding}database type            : ${DATABASE_TYPE}"

echo ""

if [ "${CDB}" = "YES" ]
then
  if [ "${style}" = "human" ]
  then
    echo "${padding}pdbs:"
  else
    echo "${padding}<PDBS>"
  fi

  padding_save=${padding}
  padding="    ${padding}"
  sed -e "s/^/${padding}/" -e "s/^$//" ${tmpfile}.pdbs

  if [ "${style}" = "human" ]
  then
    :
  else
    echo "${padding_save}</PDBS>"
  fi
fi





print_end ${TAG}

exit $EXITCODE

